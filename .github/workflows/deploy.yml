name: Deploy to Yandex Cloud

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  YCR_REGISTRY: cr.yandex/${{ secrets.YCR_REGISTRY_ID }}
  YC_VM_ID: ${{ secrets.VM_ID }}

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Нужно для semantic-release

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Build application
        run: npm run build
        env:
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
          CONTACT_EMAIL_TO: ${{ secrets.CONTACT_EMAIL_TO }}
          CONTACT_EMAIL_FROM: ${{ secrets.CONTACT_EMAIL_FROM }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          TRACKER_PRIVATE_KEY: ${{ secrets.TRACKER_PRIVATE_KEY }}
          TRACKER_KEY_ID: ${{ secrets.TRACKER_KEY_ID }}
          TRACKER_SERVICE_ACCOUNT_ID: ${{ secrets.TRACKER_SERVICE_ACCOUNT_ID }}
          TRACKER_ORG_ID: ${{ secrets.TRACKER_ORG_ID }}
          TRACKER_QUEUE_KEY: ${{ secrets.TRACKER_QUEUE_KEY }}
  semantic-release:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    permissions:
      contents: write  # To push tags and create releases
      issues: write    # To comment on released issues
      pull-requests: write  # To comment on released pull requests
      id-token: write  # For provenance    
    outputs:
      new-release-published: ${{ steps.semantic.outputs.new-release-published }}
      new-release-version: ${{ steps.semantic.outputs.new-release-version }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release

  deploy:
    needs: [build-and-test, semantic-release]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
      - uses: actions/checkout@v4

      - name: Set deployment environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "env_name=production" >> $GITHUB_OUTPUT
            if [[ "${{ needs.semantic-release.outputs.new-release-published }}" == "true" ]]; then
              echo "image_tag=${{ needs.semantic-release.outputs.new-release-version }}" >> $GITHUB_OUTPUT
            else
              echo "image_tag=latest" >> $GITHUB_OUTPUT
            fi
            echo "service_name=bottlecode-landing" >> $GITHUB_OUTPUT
            echo "host_domain=${{ secrets.PROD_DOMAIN }}" >> $GITHUB_OUTPUT
          else
            echo "env_name=staging" >> $GITHUB_OUTPUT
            echo "image_tag=staging" >> $GITHUB_OUTPUT
            echo "service_name=bottlecode-landing" >> $GITHUB_OUTPUT
            echo "host_domain=${{ secrets.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT
          fi

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Yandex Cloud CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH      
          
      - name: Configure Yandex Cloud CLI
        env:
          YC_OAUTH_TOKEN: ${{ secrets.YC_OAUTH_TOKEN }}
          YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
        run: |
          yc config set token "$YC_OAUTH_TOKEN"
          yc config set cloud-id "$YC_CLOUD_ID"
          yc config set folder-id "$YC_FOLDER_ID"
          export IAM_TOKEN=`yc iam create-token`
          echo "::add-mask::$IAM_TOKEN"
          echo "IAM_TOKEN=$IAM_TOKEN" >> $GITHUB_ENV      
          
      - name: Login to Yandex Container Registry
        run: echo "${{ secrets.YC_OAUTH_TOKEN }}" | docker login --username oauth --password-stdin cr.yandex

      - name: Debug secrets and build context
        env:
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
          CONTACT_EMAIL_TO: ${{ secrets.CONTACT_EMAIL_TO }}
          CONTACT_EMAIL_FROM: ${{ secrets.CONTACT_EMAIL_FROM }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          TRACKER_PRIVATE_KEY: ${{ secrets.TRACKER_PRIVATE_KEY }}
          TRACKER_PRIVATE_KEY_B64: ${{ secrets.TRACKER_PRIVATE_KEY_B64 }}
          TRACKER_KEY_ID: ${{ secrets.TRACKER_KEY_ID }}
          TRACKER_SERVICE_ACCOUNT_ID: ${{ secrets.TRACKER_SERVICE_ACCOUNT_ID }}
          TRACKER_ORG_ID: ${{ secrets.TRACKER_ORG_ID }}
          TRACKER_QUEUE_KEY: ${{ secrets.TRACKER_QUEUE_KEY }}
        run: |
          echo "Checking secrets (length only, not values):"
          echo "NEXT_PUBLIC_SITE_URL length: ${#NEXT_PUBLIC_SITE_URL}"
          echo "NEXT_PUBLIC_APP_URL length: ${#NEXT_PUBLIC_APP_URL}"
          echo "CONTACT_EMAIL_TO length: ${#CONTACT_EMAIL_TO}"
          echo "CONTACT_EMAIL_FROM length: ${#CONTACT_EMAIL_FROM}"
          echo "SMTP_HOST length: ${#SMTP_HOST}"
          echo "SMTP_PORT length: ${#SMTP_PORT}"
          echo "SMTP_SECURE length: ${#SMTP_SECURE}"
          echo "SMTP_USER length: ${#SMTP_USER}"
          echo "SMTP_PASS length: ${#SMTP_PASS}"          echo "TRACKER_PRIVATE_KEY length: ${#TRACKER_PRIVATE_KEY}"
          echo "TRACKER_PRIVATE_KEY_B64 length: ${#TRACKER_PRIVATE_KEY_B64}"
          echo "TRACKER_KEY_ID length: ${#TRACKER_KEY_ID}"
          echo "TRACKER_SERVICE_ACCOUNT_ID length: ${#TRACKER_SERVICE_ACCOUNT_ID}"
          echo "TRACKER_ORG_ID length: ${#TRACKER_ORG_ID}"
          echo "TRACKER_QUEUE_KEY length: ${#TRACKER_QUEUE_KEY}"
          echo "\nListing files in build context:"
          ls -la
          echo "\nChecking for Dockerfile:"
          if [ -f Dockerfile ]; then echo "Dockerfile found"; else echo "Dockerfile NOT found"; fi


      - name: Build and push Docker image
        env:
          YCR_REGISTRY_ID: ${{ secrets.YCR_REGISTRY_ID }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL }}
          CONTACT_EMAIL_TO: ${{ secrets.CONTACT_EMAIL_TO }}
          CONTACT_EMAIL_FROM: ${{ secrets.CONTACT_EMAIL_FROM }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          TRACKER_PRIVATE_KEY: ${{ secrets.TRACKER_PRIVATE_KEY }}
          TRACKER_PRIVATE_KEY_B64: ${{ secrets.TRACKER_PRIVATE_KEY_B64 }}
          TRACKER_KEY_ID: ${{ secrets.TRACKER_KEY_ID }}
          TRACKER_SERVICE_ACCOUNT_ID: ${{ secrets.TRACKER_SERVICE_ACCOUNT_ID }}
          TRACKER_ORG_ID: ${{ secrets.TRACKER_ORG_ID }}
          TRACKER_QUEUE_KEY: ${{ secrets.TRACKER_QUEUE_KEY }}
        run: |
          set -x
          IMAGE_TAG="${{ steps.env.outputs.image_tag }}"
          REGISTRY="cr.yandex/${YCR_REGISTRY_ID}"
          IMAGE_NAME="bottle-code-landing"

          echo "Building Docker image: ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"

          docker build \
            --build-arg NEXT_PUBLIC_SITE_URL="$NEXT_PUBLIC_SITE_URL" \
            --build-arg NEXT_PUBLIC_APP_URL="$NEXT_PUBLIC_APP_URL" \
            --build-arg CONTACT_EMAIL_TO="$CONTACT_EMAIL_TO" \
            --build-arg CONTACT_EMAIL_FROM="$CONTACT_EMAIL_FROM" \
            --build-arg SMTP_HOST="$SMTP_HOST" \
            --build-arg SMTP_PORT="$SMTP_PORT" \
            --build-arg SMTP_SECURE="$SMTP_SECURE" \
            --build-arg SMTP_USER="$SMTP_USER" \
            --build-arg SMTP_PASS="$SMTP_PASS" \
            --build-arg TRACKER_PRIVATE_KEY="$TRACKER_PRIVATE_KEY" \
            --build-arg TRACKER_PRIVATE_KEY_B64="$TRACKER_PRIVATE_KEY_B64" \
            --build-arg TRACKER_KEY_ID="$TRACKER_KEY_ID" \
            --build-arg TRACKER_SERVICE_ACCOUNT_ID="$TRACKER_SERVICE_ACCOUNT_ID" \
            --build-arg TRACKER_ORG_ID="$TRACKER_ORG_ID" \
            --build-arg TRACKER_QUEUE_KEY="$TRACKER_QUEUE_KEY" \
            -t "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}" .

          echo "Pushing Docker image: ${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
          docker push "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"

          # Tag and push as latest for production
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "Tagging and pushing as latest"
            docker tag "${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}" "${REGISTRY}/${IMAGE_NAME}:latest"
            docker push "${REGISTRY}/${IMAGE_NAME}:latest"
          fi      - name: Upload docker-compose.yml to server
        run: |
          export VM_ID="${{ secrets.VM_ID }}"
          cat docker-compose.yml | yc compute ssh --id "$VM_ID" -- "sudo tee /opt/bottle-code-landing/docker-compose.yml > /dev/null"

      - name: Upload environment variables to server
        run: |
          export VM_ID="${{ secrets.VM_ID }}"
          # Создаём .env файл с runtime переменными
          cat << EOF | yc compute ssh --id "$VM_ID" -- "sudo tee /opt/bottle-code-landing/.env > /dev/null"
          YCR_REGISTRY_ID=${{ secrets.YCR_REGISTRY_ID }}
          NODE_ENV=production
          CONTACT_EMAIL_TO=${{ secrets.CONTACT_EMAIL_TO }}
          CONTACT_EMAIL_FROM=${{ secrets.CONTACT_EMAIL_FROM }}
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_SECURE=${{ secrets.SMTP_SECURE }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASS=${{ secrets.SMTP_PASS }}
          TRACKER_PRIVATE_KEY=${{ secrets.TRACKER_PRIVATE_KEY }}
          TRACKER_PRIVATE_KEY_B64=${{ secrets.TRACKER_PRIVATE_KEY_B64 }}
          TRACKER_KEY_ID=${{ secrets.TRACKER_KEY_ID }}
          TRACKER_SERVICE_ACCOUNT_ID=${{ secrets.TRACKER_SERVICE_ACCOUNT_ID }}
          TRACKER_ORG_ID=${{ secrets.TRACKER_ORG_ID }}
          TRACKER_QUEUE_KEY=${{ secrets.TRACKER_QUEUE_KEY }}
          EOF

      - name: Deploy to server
        run: |
          export VM_ID="${{ secrets.VM_ID }}"
          yc compute ssh --id "$VM_ID" -- "
            cd /opt/bottle-code-landing &&
            sudo docker login --username iam --password '$IAM_TOKEN' cr.yandex &&
            sudo docker compose pull bottlecode-landing &&
            sudo docker compose up -d bottlecode-landing
          "

      - name: Health check
        run: |
          echo "Waiting for deployment to complete..."
          sleep 30
          
          DOMAIN="${{ steps.env.outputs.host_domain }}"
          if [[ "${{ steps.env.outputs.env_name }}" == "staging" ]]; then
            DOMAIN="staging.$DOMAIN"
          fi
          
          echo "Checking health of https://$DOMAIN"
          curl -f https://$DOMAIN || exit 1
          echo "Deployment successful!"

      - name: Cleanup old Docker images
        run: |
          export VM_ID="${{ secrets.VM_ID }}"
          yc compute ssh --id "$VM_ID" -- "
            sudo docker image prune -f &&
            sudo docker system prune -f
          "
